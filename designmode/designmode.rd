六大设计原则
 一.单一原则(SRP)
定义：应该有且仅有一个原因引起类的变更。
 组合关系会引起类间耦合过重、类的数量增加等问题。
单一职责好处:
 ● 类的复杂性降低，实现什么职责都有清晰明确的定义；
 ● 可读性提高，复杂性降低，那当然可读性提高了；
 ● 可维护性提高，可读性提高，那当然更容易维护了；
 ● 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好
 改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大
 的帮助。
接口设计尽量做到单一职责原则
二.里氏替换原则(LSP)
定义1:如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，
程序P的行为没有发生变化，那么类型S是类型T的子类型。
定义2:所有引用基类的地方必须能透明地使用其子类的对象
第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且
替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但
是，反过来就不行了，有子类出现的地方，父类未必就能适应

在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明
类的设计已经违背了LSP原则。

在程序中，每增加一个类，所有与这个类的父类有关系的类，都得修改肯定不行。

如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发
生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
三.依赖倒置原则（DIP）
定义:
1.高层模块不应该依赖底层模块，两者都应该依赖其抽象
2.抽象不应该依赖细节
3.细节应该依赖抽象
依赖倒置在java中的应用：
1.模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
2.接口或抽象类不应该依赖实现
3.实现类应该依赖接口或者抽象类。

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风
险，提高代码的可读性和可维护性。

抽象是对实现的约束，对依赖者而言，也是一种契约，不仅仅约束自己，还同时约束自
己与外部的关系，其目的是保证所有的细节不脱离契约的范畴，确保约束双方按照既定的契
约（抽象）共同发展，只要抽象这根基线在，细节就脱离不了这个圈圈，始终让你的对象做
到“言必信，行必果”。

对象的依赖关系有三种方式来传递：
1.构造函数传递依赖对象
在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注
入。
2.Setter方法传递依赖对象
在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入，按
照这种方式的注入
3.接口声明依赖对象
在接口的方法中声明依赖对象

依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，
不互相影响，实现模块间的松耦合。我们怎么在项目中使用这个规则呢？只要遵循以下的几
个规则就可以：
每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。
变量的表面类型尽量是接口或者是抽象类。
任何类都不应该从具体类派生。
尽量不要覆写基类的方法。
结合里氏替换原则使用。

四.接口隔离原则(ISP--Interface Segregation Principle)
建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少
接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维
护性。
保持接口纯洁性
接口隔离原则是对接口进行规范约束，其包含以下4层含义：
1.接口要尽量小
 根据接口隔离原则拆分接口时，首先必须满足单一职责原则.
2.接口要高内聚
什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。
要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越
少，同时也有利于降低成本。
3.定制服务
定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用
定制服务就必然有一个要求：只提供访问者需要的方法.
4.接口设计是有限度的
接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原
子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下
几个规则来衡量:
一个接口只服务于一个子模块或业务逻辑；
通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨
肉”，而不是“肥嘟嘟”的一大堆方法；
已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化
处理；
了解环境，拒绝盲从.
五.迪米特法则(Law of Demeter,LoD)
迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge
Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最
少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调
用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public
方法，我就调用这么多，其他的我一概不关心。
1.只和朋友类交流
朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内
部的类不属于朋友类。
一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种
情况（在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同），类
与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在
的对象，当然，JDK API提供的类除外。
2.朋友间也是有距离的
一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。
因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少
public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前
不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。
注意:迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的
   public变量，尽量内敛，多使用private、package-private、protected等访问权限。
3.是自己的就是自己的
如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。
4.谨慎使用Serializable


